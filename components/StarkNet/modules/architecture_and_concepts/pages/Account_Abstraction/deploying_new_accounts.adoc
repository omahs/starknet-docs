[id="deploying_new_accounts"]
= Deploying new accounts

// Todo add flow here

Since xref:documentation:starknet_versions:version_notes.adoc#version0.10.3[StarkNet version 0.10.3] the historical method of deploying accounts on StarkNet (sending a `deploy` transaction) has been removed.

It has been replaced with a new flow, `deploy_account` which accommodates existing accounts to deploy an account and also pay fees for the deployment.

The `deploy_account` transaction solves the problem of paying for deployment while not having an account.

This involves deciding on the account type (that is, class_hash) you want to deploy, computing your would-be account address off-chain, and sending funds to this address.

Once the address has enough funds to pay for the deployment, the user can send a `deploy_account` transaction.


## Issues with legacy deploy transaction

There were several issues that we aim to resolve by introducing the `deploy_account` transaction:

* Sequencers having the ability to charge arbitrarily high fees, thus potentially draining user funds from a pre-funded account
* A bad actor having the ability to carry out a sequencer DOS attack by sending multiple, invalid `deploy_account` transactions. This would result in the sequencer not being compensated for work completed.

## The solution
To prevent the above scenarios, `&lowbar;&lowbar;validate_deploy&lowbar;&lowbar;` was introduced.

This enforces some limitations on `deploy_account` transactions, via validation execution namely:

* Limited # of Cairo steps
* Limited # of builtin applications
* No external contract calls (library calls and self-calls are allowed)

In future versions these same limitations will be introduced to the constructor as well.

## Validate deploy

A new, optional validation entrypoint: `&lowbar;&lowbar;validate_deploy&lowbar;&lowbar;`, has been added to avoid being able to drain funds from a pre-funded address.

This entrypoint should be included in any accounts or contracts that wish to allow this updated flow.


To see why this is important, consider the following example scenario:

Suppose that StarkNet has gas metering and that a sequencer may include a `deploy_account` transaction that charges the user according to the gas consumed in the constructor execution.

While the sequencer does not have the power to deploy a different contract for the user, the address is xref:Contracts/contract-address.adoc[bound] to the class hash and constructor arguments, the sequencer does have the power to manipulate the price.

If the user does not sign a price (gas price, or in the present version of StarkNet, `max_fee`), then we must resort to schemes in the spirit of https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1559.md[EIP1559], to determine the deployment cost.

In this case, the sequencer can manipulate the block in order to charge an arbitrarily high fee and drain the user’s funds.

`&lowbar;&lowbar;validate_deploy&lowbar;&lowbar;` expects the following arguments:

* class hash
* contract address salt
* constructor arguments - the arguments expected by the contract’s constructor (this will be enforced in the compiler).

Consider an account with the following constructor signature:

[#constructor_signature]
[source,cairo]
----
@constructor
func constructor{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
    _public_key: felt
)
----

Then the signature of `&lowbar;&lowbar;validate_deploy`&lowbar;&lowbar; must be:

[#call_validate_deploy]
[source,cairo]
----
func __validate_deploy__{
    syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr, ecdsa_ptr: SignatureBuiltin*
}(class_hash: felt, contract_address_salt: felt, _public_key: felt)
----

[NOTE]
====
The transaction hash and `max_fee` are accessible through the `get_tx_info` system call.
====

ill being researched internally and will be shared in the future. In particular, we may block additional system calls that introduce the risk of validation being time-dependent, e.g. `get_block_timestamp` or `get_block_number`.